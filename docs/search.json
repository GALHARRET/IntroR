[
  {
    "objectID": "graphiques.html",
    "href": "graphiques.html",
    "title": "5  Les graphiques",
    "section": "",
    "text": "5.1 Graphiques univariées",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "graphiques.html#graphiques-univariées",
    "href": "graphiques.html#graphiques-univariées",
    "title": "5  Les graphiques",
    "section": "",
    "text": "5.1.1 Variable qualitative :\nOn veut représenter le nombre de voitures correspondant à chaque catégorie de cyl :\n\ndata(\"mtcars\")\nlibrary(ggplot2)\nggplot(mtcars,\n       aes(x=factor(cyl)))+\n  geom_bar()\n\nUn graphique ggplot commence toujours par la fonction du même nom dans laquelle on indique le data frame (obligatoirement un df) et aes (Aesthetic mappings) qui décrit les variables qui vont être décrites.\nOn peut ajouter des titres aux axes et un titre au graphe :\n\nggplot(mtcars,\n       aes(x=factor(cyl)))+\n  geom_bar()+\n  labs(\n    title=\"Diagramme en barres\",\n    x=\"NB cylindres\",\n    y=\"NB voitures\"\n  )\n\n\n\n\n\n\n\n\nOn peut aussi paramétrer le fond du graphique :\n\nggplot(mtcars,\n       aes(x=factor(cyl)))+\n  geom_bar()+\n  labs(\n    title=\"Diagramme en barres\",\n    x=\"NB cylindres\",\n    y=\"NB voitures\"\n  )+\n  theme_minimal()\n\n\n\n\n\n\n\n\nOu sous la forme de diagramme circulaire (avec les poucentages correspondants)\n\nlibrary(scales)\ndf=as.data.frame(table(mtcars$cyl))\ncolnames(df)[1]=\"Nb.cyl\"\ndf=df%&gt;%\n  mutate(Prop=percent(Freq/sum(Freq)))\nggplot(df, aes(x=\"\", y=Prop,fill=Nb.cyl)) +\n  geom_bar(stat=\"identity\", width=1) +\n  geom_text(aes(label = Prop),\n            position = position_stack(vjust = 0.5))+\n  coord_polar(\"y\", start=0)+\n  theme_void()\n\n\n\n\n\n\n\n\nOn peut aussi les mettre selon la même technique sur le diagramme en barres.\n\n\n5.1.2 Variable quantitative\nSous la forme d’histogramme :\n\nggplot(mtcars,aes(x=wt))+\n  geom_histogram(bins=5,alpha=.4)+\n  theme_minimal()\n\n\n\n\n\n\n\n\nLes effectifs sont représentés en ordonnées, bins donne le nombre de classes qui vont être construites et alpha\nou bien en points par points (on va utiliser la couleur pour distinguer les espèces) :\n\nggplot(mtcars,aes(x=\"\",y=wt))+\n  geom_jitter(width = .05)+\n  theme_minimal()\n\nOn peut y ajouter un boxplot :\n\nggplot(mtcars,aes(x=\"\",y=wt))+\n  geom_boxplot()+\n  geom_jitter(width = .05)+\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "graphiques.html#graphiques-bivariés",
    "href": "graphiques.html#graphiques-bivariés",
    "title": "5  Les graphiques",
    "section": "5.2 Graphiques bivariés :",
    "text": "5.2 Graphiques bivariés :\n\n5.2.1 Une variable quantitative en fonction d’une variable qualitative\nPour les boxplot c’est simple :\n\nggplot(mtcars,aes(x=factor(cyl),y=wt))+\n  geom_boxplot()+\n  theme_minimal()+\n  labs(x=\"Nb cylindres\")\n\n\n\n\n\n\n\n\nPour les histogrammes :\n\nggplot(mtcars,aes(x=wt,fill = factor(cyl)))+\n  geom_histogram(alpha=.4,bins=5)\n\n\n\n\n\n\n\n\nou bien :\n\nggplot(mtcars,aes(x=wt))+\n  geom_histogram(bins=5,alpha=.4)+\n  facet_grid(~cyl)+theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "graphiques.html#une-variable-quantitative-en-fonction-dune-autre-variable-quantitative",
    "href": "graphiques.html#une-variable-quantitative-en-fonction-dune-autre-variable-quantitative",
    "title": "5  Les graphiques",
    "section": "5.3 Une variable quantitative en fonction d’une autre variable quantitative",
    "text": "5.3 Une variable quantitative en fonction d’une autre variable quantitative\n\nggplot(mtcars,aes(x=wt,y=mpg))+\n  geom_point()+theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "graphiques.html#une-variable-qualitative-en-fonction-dune-autre-variable-qualitative",
    "href": "graphiques.html#une-variable-qualitative-en-fonction-dune-autre-variable-qualitative",
    "title": "5  Les graphiques",
    "section": "5.4 Une variable qualitative en fonction d’une autre variable qualitative",
    "text": "5.4 Une variable qualitative en fonction d’une autre variable qualitative\n\nlibrary(ggstats)\nggplot(mtcars,aes(x=factor(cyl),fill=factor(vs)))+\n  labs(\n    x=\"Nb de cylindres\",\n    title=\"Proportions des classes\",\n    y=\"Proportions\"\n  )+\n  geom_prop_bar()+\n  geom_prop_text()+\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "graphiques.html#exercices",
    "href": "graphiques.html#exercices",
    "title": "5  Les graphiques",
    "section": "5.5 Exercices",
    "text": "5.5 Exercices\n\n5.5.1 Exercice 1 :\nTélécharger le fichier temperat puis ouvrez le dans RStudio (utiliser l’interface graphique), la première colonne correspondra aux noms des lignes du data.frame.\nPremier travail : On veut reproduire le graphe suivant :\n\n\n\n\n\n\n\n\n\naide : utiliser label=… dans aes et geom_text()\nDeuxième travail : Représenter les températures moyennes pour les trois villes : Nantes, Brest et Rennes.\n\n\nVoir la correction\nlibrary(reshape2)\ndf=as.data.frame(t(data%&gt;%select(Jan:Dec)))\ndf$mois=1:12\ndf2=df%&gt;%\n  select(mois,Nant,Renn,Bres)%&gt;%\n  melt(id.vars = \"mois\",variable.name = \"Ville\")\nggplot(df2,aes(x=mois,y=value,color=Ville))+\n  geom_point()+\n  geom_line()+\n  theme_minimal()+\n  scale_x_discrete(limits=factor(1:12),labels=rownames(df))\n\n\n\n\n\n\n\n\n\nOn peut redéfinir\n\n\n5.5.2 Exercice 2 :\nTélécharger le fichier bordeaux1 et ouvrez le dans R à l’aide de l’interface graphique. Les années seront utilisées pour nommer les lignes.\nIl s’agit des données des vins de Bordeaux issues de “Méthodes statistiques en gestion” (M. Tenenhaus, Dunod, 1994).\nOn cherche à étudier l’éventuelle relation entre la qualité du vin et les variables météorologiques. Les variables sont les suivantes : TEMPERATURE : somme des températures moyennes journalières, SOLEIL : durée d’insolation, CHALEUR : nombre de jours de grande chaleur, PLUIE : hauteur des pluies, Y (QUALITE DU VIN) : 1 (Bon), 2 (Moyen), 3 (Médiocre).\n\nFaire les boxplot des variables température et pluie en fonction de la qualité du vin. Les deux graphes seront dans une même fenêtre. La ligne en pointillé horizontale représente la moyenne globale de la variable (voir fonction abline()). On reclassera les modalités de la variable qualité.\n\n\n\nVoir la correction\ndata$Y1&lt;-factor(data$Y1,levels=c(\"médiocre\",\"moyen\",\"bon\"))\nggplot(data,aes(x=Y1,y=Temperature))+\n  geom_boxplot()+\n  labs(\n    x=\"Qualité du vin\",\n    y=\"Température\"\n  )+\n  geom_hline(yintercept = mean(data$Temperature),\n             linetype=\"dashed\",\n             colour=\"red\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nVoir la correction\nggplot(data,aes(x=Y1,y=Pluie))+\n  geom_boxplot()+\n  labs(\n    x=\"Qualité du vin\",\n    y=\"Pluie\"\n  )+\n  geom_hline(yintercept = mean(data$Pluie),\n             linetype=\"dashed\",\n             colour=\"red\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nFaire les 3 histogrammes de la variable chaleur en fonction de la qualité du vin dans une même fenêtre graphique. La droite verticale correspond à la moyenne globale.\n\n\n\nVoir la correction\nggplot(data,aes(x=Chaleur))+\n  geom_histogram(bins=5,alpha=.5)+\n  facet_grid(~Y1)+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nCréer une variable pluie_quali qui correspondra à la variable PLUIE et dont les modalités seront :\n\n\nFaibles lorsque la variable PLUIE sera inférieure à sa médiane\nFortes lorsque la variable PLUIE sera supérieure ou égale à sa médiane.\n\nDessiner la répartition de la qualité des vins en fonctions des deux modalités Faibles et Fortes.\n\n\nVoir la correction\nmed&lt;-median(data$Pluie)\ndata$pluie_quali&lt;-factor(\n  as.numeric(data$Pluie&gt;med),labels = c(\"Faibles\",\"Fortes\"))\nggplot(data,aes(x=Y1,fill=pluie_quali))+\n  geom_prop_bar()+\n  geom_prop_text()+\n  xlab(\"Qualité du vin\")\n\n\n\n\n\n\n\n\n\n\nReproduire le graphique suivant\n\n\n\nVoir la correction\nggplot(data,aes(x=Temperature,y=Pluie,color=Y1,label=Annee))+\n  geom_text()+theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "2  Les matrices",
    "section": "",
    "text": "2.1 Définition et fonctions de base\nA=matrix(c(1,2,3,\n           2,1,-1,\n           -3,-1,1),nrow=3)\nQuelques fonctions utiles la dimension de la matrice\ndim(A)\n\n[1] 3 3\nLe résultat est donc un vecteur ayant deux éléments le nombre de ligne et le nombre de colonnes",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Les matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#indexation-des-éléments-dune-matrice",
    "href": "matrices.html#indexation-des-éléments-dune-matrice",
    "title": "2  Les matrices",
    "section": "2.2 Indexation des éléments d’une matrice",
    "text": "2.2 Indexation des éléments d’une matrice\nLes éléments d’une matrice sont identifiés par un numéro de ligne et de colonne entre crochets A[i,j]\n\nA[1,2]\n\n[1] 2\n\n# première ligne de A \nA[1,]\n\n[1]  1  2 -3\n\n# première colonne de A\nA[,1]\n\n[1] 1 2 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Les matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#exercice",
    "href": "matrices.html#exercice",
    "title": "2  Les matrices",
    "section": "2.3 Exercice :",
    "text": "2.3 Exercice :\n\nGénérer un vecteur fillmat contenant 250 valeurs tirées selon une loi uniforme continue de paramètres 0 et 10 grâce à la fonction runif.\n\n\n\nVoir la correction\nfillmat&lt;-runif(250,0,10)\n\n\n\nCréer une matrice Mesures de 50 lignes et 5 colonnes contenantes les valeurs de fillmat. Les colonnes seront nommées Mesure1,…, Mesure5.\n\n\n\nVoir la correction\nMesures&lt;-matrix(fillmat,nrow=50)\ncolnames(Mesures)&lt;-paste(\"Mesure\",1:5,sep=\"\")\n\n\n\nCréer un vecteur Groupe de taille 50 contenant des valeurs entières entre 1 et 5 (fonction sample). On interprétera Groupe comme le groupe d’appartenance des 50 lignes de Mesures. Ajouter cette colonne à la matrice Mesures.\n\n\n\nVoir la correction\nGroupe&lt;-sample(1:5,50,replace=T)\n\n\n\nCombien de lignes appartiennent au groupe n°2 ?\n\n\n\nVoir la correction\nsum(Groupe==2)\n\n\n[1] 6\n\n\n\nAfficher le numéro des lignes appartenant au groupe n°2.\n\n\n\nVoir la correction\nwhich(Groupe==2)\n\n\n[1]  4 13 25 26 27 43\n\n\n\nAfficher les lignes de Mesures correspondant au groupe n°2.\n\n\n\nVoir la correction\nMesures[Groupe==2,]\n\n\n      Mesure1  Mesure2  Mesure3   Mesure4  Mesure5\n[1,] 8.397356 7.956640 2.989363 2.1727732 3.634908\n[2,] 5.041255 1.386101 3.560883 7.2442525 3.181113\n[3,] 3.376853 6.980315 9.390400 2.8520368 3.150224\n[4,] 9.848660 9.981776 4.290314 6.7352734 9.533691\n[5,] 7.068545 7.605487 4.667439 0.6695342 4.259496\n[6,] 5.159697 5.803267 6.349930 6.2747822 4.470055\n\n\n\nDéterminer combien Mesures contient de valeurs inférieures à 5 (on exclura la colonne groupe du comptage).\n\n\n\nVoir la correction\nsum(Mesures[,-6]&lt;5)\n\n\n[1] 135\n\n\n\nCalculer la moyenne des valeurs de Mesures correspondant au groupe n°4.\n\n\n\nVoir la correction\nmean(Mesures[Groupe==4,])\n\n\n[1] 4.452221\n\n\n\nMême question mais pour les 3 premières colonnes uniquement.\n\n\n\nVoir la correction\nmean(Mesures[Groupe==4,1:3])\n\n\n[1] 4.058999\n\n\n\nAppliquer à Mesures les fonctions dim, ncol et nrow. A quoi correspondent ces nombres ?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Les matrices</span>"
    ]
  },
  {
    "objectID": "data_frame.html",
    "href": "data_frame.html",
    "title": "3  Les data frames",
    "section": "",
    "text": "3.1 Création d’un data frame\nOn crée deux variables x et y contenant \\(n=100\\) nombres distribués selon une loi uniforme continue sur [0,20] (fonction runif) et une variable gr (expliquer le résultat du code correspondant). La fonction round permet d’arrondir.\nx&lt;-round(runif(100,0,20),1)\ny&lt;-round(runif(100,0,20),1)\ngr&lt;-sample(c(\"ING1\",\"ING2\"),size=100,replace=T,prob=c(0.6,0.4))\ndf&lt;-data.frame(NoteF=x,NoteM=y,gr=gr)\nL’indexation des éléments dans un data-frame est la même que dans une matrice :\ndf[1,1]\n\n[1] 9.8\nOn peut également sélectionner une colonne du data frame via $\ndf$NoteF\n\n  [1]  9.8 14.4  6.4  2.8  1.9 10.0 12.3 16.8  1.6 13.8 16.3  0.6  9.0 17.8 17.9\n [16] 10.6  4.6  8.2 11.5  0.8  6.6 17.7 15.8 15.8  6.2  5.7 11.4  0.5 19.2 12.0\n [31] 13.9 10.8 13.3  4.3 15.4  0.4  3.9 17.9 12.1 14.6  1.8 11.8  7.0 11.5  1.0\n [46] 16.2 11.7  5.7 14.8  9.9 12.6  4.9 10.1  9.3  8.3 13.6 14.5 14.6  8.6 10.2\n [61] 14.7 15.2  3.9 19.6 12.8  3.7 17.6 12.7 15.7  3.3 19.1  3.2  0.4  8.5 10.1\n [76] 17.7 17.8  2.3 19.7 13.2 10.1 12.6 14.4  3.2  2.6 15.0  1.4 18.2  7.2  7.8\n [91] 15.0  2.5 18.5 17.3 11.8 11.9 13.0  2.5  3.8  0.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#les-fonctions-utiles-pour-les-data-frame",
    "href": "data_frame.html#les-fonctions-utiles-pour-les-data-frame",
    "title": "3  Les data frames",
    "section": "3.2 Les fonctions utiles pour les data frame",
    "text": "3.2 Les fonctions utiles pour les data frame\n\n3.2.1 summary\nCette fonction permet de résumer l’ensemble des variables du data frame.\n\nsummary(df)\n\n     NoteF            NoteM             gr           \n Min.   : 0.100   Min.   : 0.100   Length:100        \n 1st Qu.: 4.825   1st Qu.: 6.125   Class :character  \n Median :11.450   Median :11.550   Mode  :character  \n Mean   :10.228   Mean   :10.662                     \n 3rd Qu.:14.725   3rd Qu.:15.000                     \n Max.   :19.700   Max.   :19.600                     \n\n\n\n\n3.2.2 apply\nLa fonction apply permet d’appliquer une fonction sur les lignes (1) ou les colonnes d’un data frame : par exemple si on souhaite appliquer la fonction moyenne (mean) sur les colonnes du data frame df on utilise :\n\napply(df[,1:2],2,mean)\n\n NoteF  NoteM \n10.228 10.662 \n\n\nRemarque : on n’a utilisé que les deux premières colonnes du data frame car la troisième n’est pas numérique (donc on ne peut pas calculer sa moyenne).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#importation-dun-data-frame-inclus-dans-un-package",
    "href": "data_frame.html#importation-dun-data-frame-inclus-dans-un-package",
    "title": "3  Les data frames",
    "section": "3.3 Importation d’un data frame inclus dans un package",
    "text": "3.3 Importation d’un data frame inclus dans un package\nPour accéder aux data frames de R :\n\ndata()\n\nensuite on peut grâce à la fonction help obtenir de l’aide sur l’un des data frame :\n\nhelp(\"mtcars\")\n\nEnsuite on charge le jeu de données via\n\ndata(\"mtcars\")\n\nUne fois le data frame importé on constate qu’il est présent dans la fenêtre environnement\n\n\n\nFenêtre environnement",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#fusion-de-plusieurs-catégories",
    "href": "data_frame.html#fusion-de-plusieurs-catégories",
    "title": "3  Les data frames",
    "section": "4.1 Fusion de plusieurs catégories",
    "text": "4.1 Fusion de plusieurs catégories\n\nstatut_pro=replace(statut_pro,statut_pro %in% c(\"étudiant\",\n                                     \"en activité\"),\"en activité\")\ntable(statut_pro)\n\nstatut_pro\n             étudiant           en activité en recherche d'emploi \n                    0                    44                    27 \n        à la retraite \n                   29 \n\n\nLe problème est que la catégorie étudiant existe encore donc il faut que R “l’oublie”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#oubli-de-niveaux",
    "href": "data_frame.html#oubli-de-niveaux",
    "title": "3  Les data frames",
    "section": "4.2 Oubli de niveaux",
    "text": "4.2 Oubli de niveaux\n\nstatut_pro=droplevels(statut_pro)\ntable(statut_pro)\n\nstatut_pro\n          en activité en recherche d'emploi         à la retraite \n                   44                    27                    29",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#importation-dune-base-de-données-externe",
    "href": "data_frame.html#importation-dune-base-de-données-externe",
    "title": "3  Les data frames",
    "section": "4.3 Importation d’une base de données externe",
    "text": "4.3 Importation d’une base de données externe\nOn peut utiliser une interface graphique pour ouvrir les fichiers contenant le data frame. Les plus courants sont :\n\n*.csv : (Comma Separed Values) ce sont des fichiers de type tableaux sans mise en forme\n*.xlsx : fichiers produits à partir du logiciel excel\n*.ods : fichiers produits à partir du logiciel Calc de LibreOffice.\n\n\n\n\nMenu Importer\n\n\nOn va importer le data frame contenu dans le fichier bordeaux.csv disponible sur Connect (vous devez le télécharger).\nVous avez deux solutions : From text (base)\n\n\n\nImportation avec la librairie base\n\n\nFrom text (readr)\n\n\n\nImportation avec la librairie readr\n\n\nEnsuite il est recommandé de copier/coller la ligne de commande dans le script R afin de pas à avoir à reproduire la manipulation à chaque session de travail sur le fichier bordeaux.csv\n\n\n\nLa fonction read_csv()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#exercice-sur-le-data-frame-iris",
    "href": "data_frame.html#exercice-sur-le-data-frame-iris",
    "title": "3  Les data frames",
    "section": "4.4 Exercice sur le data frame iris",
    "text": "4.4 Exercice sur le data frame iris\n\nCharger le fichier de données iris. Lire l’aide de iris pour comprendre le jeu de données.\n\n\n\nVoir la correction\ndata(\"iris\")\nhelp(\"iris\")\n\n\n\nQuel est le type de iris ? Quelles sont les dimensions de iris ?\n\n\n\nVoir la correction\nclass(iris)\ndim(iris)\n\n\n\nAppliquer la fonction str à iris. A quoi correspondent les informations renvoyées ?\n\n\n\nVoir la correction\nstr(iris)\n\n\n\nAppliquer la fonction summary à iris. A quoi correspondent les informations renvoyées ?\n\n\n\nVoir la correction\nsummary(iris)\n\n\n\nUtiliser les fonctions colnames() et rownames(). Quelles sont les informations renvoyées ?\n\n\n\nVoir la correction\nrownames(iris)\n# Le nom des lignes de iris\ncolnames(iris)\n# Le nom des colonnes de iris\n\n\n\nA l’aide la fonction de texte paste remplacer le nom des lignes par fleur 1, …, fleur 150.\n\n\n\nVoir la correction\nrownames(iris)&lt;-paste(\"fleur\",1:150,sep=\" \")\n\n\n\nPour un data frame on peut appeler une colonne par son nom en utilisant $ : iris$Sepal.Length. En utilisant cette information donner la classe de la colonne Species.\n\n\n\nVoir la correction\nclass(iris$Species)\n\n\n\nQuels sont les niveaux du facteur “Species” (fonction levels) ?\n\n\n\nVoir la correction\nlevels(iris$Species)\n\n\n\nCréer une nouvelle colonne nommée groupe (on pensera à $) dans le data frame iris identique à la colonne Species. Quelle est la classe de cette nouvelle colonne ?\n\n\n\nVoir la correction\niris$groupe=iris$Species\nclass(iris$groupe)\n\n\n\nRenommer les niveaux de la colonne groupe en A, B, C (A pour setosa, B pour versicolor, C pour virginica). Afficher les indices des lignes de iris correspondant au groupe B.\n\n\n\nVoir la correction\nlevels(iris$groupe)=c(\"A\",\"B\",\"C\")\nwhich(iris$groupe==\"B\")\n\n\n\nCréer l’ensemble des numéros de lignes correspondantes aux fleurs du groupe A. Afficher les lignes de iris correspondant au groupe A. Proposer une solution alternative.\n\n\n\nVoir la correction\nI=which(iris$groupe==\"A\")\niris[I,]\niris[iris$groupe==\"A\",]\n\n\n\nEn adoptant la même logique que la question précédente, afficher uniquement les lignes de iris où « Sepal.Length » est inférieur à 5.\n\n\n\nVoir la correction\niris[iris$Sepal.Length&lt;=5,]\n\n\n\nCombien y a-t-il d’individus ayant la longueur des sépales inférieure à 5 ?\n\n\n\nVoir la correction\nsum(iris$Sepal.Length&lt;=5)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "data_frame.html#exercice-sur-le-data-frame-mtcars",
    "href": "data_frame.html#exercice-sur-le-data-frame-mtcars",
    "title": "3  Les data frames",
    "section": "4.5 Exercice sur le data frame mtcars",
    "text": "4.5 Exercice sur le data frame mtcars\n\nCharger le data frame mtcars. Combien de véhicules et de caractéristiques sur les véhicules sont contenus dans le data frame ?\n\n\n\nVoir la correction\ndata(\"mtcars\")\nhelp(\"mtcars\")\ndim(mtcars)\n\n\n\nDeux caractéristiques sont mal identifiées dans le data frame car ce sont des variables qualitatives (facteurs), rectifier en utilisant la fonction as.factor.\n\n\n\nVoir la correction\nstr(mtcars)\nmtcars$vs=as.factor(mtcars$vs)\nmtcars$am=as.factor(mtcars$am)\n\n\n\nEn utilisant l’aide du data frame mtcars renommer les niveaux des deux facteurs précédents.\n\n\n\nVoir la correction\nlevels(mtcars$vs)=c(\"V\",\"droit\")\nlevels(mtcars$am)=c(\"Auto\",\"Manu\")\n\n\n\nEtablir la table de contingence de ces deux facteurs (fonction table)\n\n\n\nVoir la correction\ntable(mtcars$vs,mtcars$am)\n\n\n\nCalculer la moyenne des 7 premières variables (on utilisera les fonctions mean et apply).\n\n\n\nVoir la correction\napply(mtcars[,1:7],2,mean)\n\n\n\nReprendre la question pour les voitures avec un moteur à plat. De même pour les voitures ayant un moteur en V et qui sont automatiques.\n\n\n\nVoir la correction\napply(mtcars[mtcars$vs==\"V\",1:7],2,mean)\napply(mtcars[mtcars$vs==\"droit\" & mtcars$am==\"Auto\",1:7],2,mean)\n\n\n\nCalculer le nombre de voitures ayant un moteur en V qui ont au moins 3 carburateurs.\n\n\n\nVoir la correction\nsum(mtcars$vs==\"V\" & mtcars$carb&gt;=3)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les data frames</span>"
    ]
  },
  {
    "objectID": "vecteurs.html",
    "href": "vecteurs.html",
    "title": "1  Découverte de R",
    "section": "",
    "text": "1.1 Les variables\nUne variable est un objet référencé dans le programme qui associe un identificateur à une valeur d’un certain type.\nx=2\nprint(x)\n\n[1] 2\n\nmode(x)\n\n[1] \"numeric\"\n\n## Supprimer x\nrm(x)\nLes variables contenant des caractères (on utilise ““)\nx&lt;-\"bonjour\"\nprint(x)\n\n[1] \"bonjour\"\n\nmode(x)\n\n[1] \"character\"\nLes variables contenant des booléens (vrai ou faux)\nx&lt;-TRUE\nprint(x)\n\n[1] TRUE\n\nmode(x)\n\n[1] \"logical\"",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#les-variables",
    "href": "vecteurs.html#les-variables",
    "title": "1  Découverte de R",
    "section": "",
    "text": "L’identificateur est le nom de la variable utilisé pour l’appeler,\nLa valeur est ce que contient la variable,\nLe type est l’ensemble dans lequel la variable prend sa valeur.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#les-vecteurs",
    "href": "vecteurs.html#les-vecteurs",
    "title": "1  Découverte de R",
    "section": "1.2 Les vecteurs",
    "text": "1.2 Les vecteurs\n\nUn des objets de base de R\ntoutes les valeurs de même type (nombre, chaine de caractères, booléen)\ncréation via la fonction c() [combine].\n\n\na1&lt;-c(1.5,2,3.2,-1.5,0,-1)\na2&lt;-c(\"fille\",\"garçon\",\"fille\",\"fille\",\"fille\",\"fille\")\na3&lt;-c(TRUE,FALSE,TRUE,TRUE)\n\nOn peut déterminer la nature du vecteur en utilisant class() :\n\nclass(a1)\n\n[1] \"numeric\"\n\nclass(a2)\n\n[1] \"character\"\n\nclass(a3)\n\n[1] \"logical\"\n\n\nExercice :\n\nCombiner les vecteurs a1 et a2 dans un nouveau vecteur a.\nQuelle est la classe du résultat ?\n\n\n\nVoir la correction\na&lt;-c(a1,a2)\nclass(a)\n\n\n[1] \"character\"\n\n\n\nrep permet d’écrire n fois la valeur a : rep(a,n)\n\nExercice : créer un vecteur avec 5 fois fille et 10 fois garçon.\n\nrep(5,10)\n\n [1] 5 5 5 5 5 5 5 5 5 5\n\nrep(\"fille\",10)\n\n [1] \"fille\" \"fille\" \"fille\" \"fille\" \"fille\" \"fille\" \"fille\" \"fille\" \"fille\"\n[10] \"fille\"\n\n\n\nseq définit une séquence de nombre entre MIN et MAX avec un pas de L : seq(MIN,MAX,by=L)\n\n\nseq(0,1,by=0.1)\n\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\nseq(10,20,by=5)\n\n[1] 10 15 20\n\n\n\n1.2.1 Indexation et longueur d’un vecteur\nLa fonction length() permet de calculer le nombre de valeurs d’un vecteur (quelle que soit la nature du vecteur considéré).\n\nlength(a1)\n\n[1] 6\n\nlength(a2)\n\n[1] 6\n\n\nChaque élément d’un vecteur est repéré par un indice entre [].\n\na1[1]\n\n[1] 1.5\n\na1[3]\n\n[1] 3.2\n\n# Opérations sur les éléments d'un vecteur\na1[1]+a1[3]\n\n[1] 4.7\n\na1[1]/a1[3]\n\n[1] 0.46875\n\n\nOn peut changer la valeur de a1[3] en lui affectant une nouvelle valeur :\n\na1[3]&lt;- -3\na1\n\n[1]  1.5  2.0 -3.0 -1.5  0.0 -1.0\n\n\nOn peut aussi ajouter de nouvelles valeurs aux vecteurs a1\n\na1[12]&lt;-10\na1[13]&lt;-11",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#les-calculs-de-base-avec-un-vecteur",
    "href": "vecteurs.html#les-calculs-de-base-avec-un-vecteur",
    "title": "1  Découverte de R",
    "section": "1.3 Les calculs de base avec un vecteur",
    "text": "1.3 Les calculs de base avec un vecteur\nOn peut ajouter, soustraire, multiplier des vecteurs entre eux à condition qu’ils soient de même longeur et qu’ils soient numériques.\n\na1&lt;-seq(10,20,by=1)\na2&lt;-seq(20,30,by=1)\na1+a2\n\n [1] 30 32 34 36 38 40 42 44 46 48 50\n\na2-a1\n\n [1] 10 10 10 10 10 10 10 10 10 10 10\n\na1*a2\n\n [1] 200 231 264 299 336 375 416 459 504 551 600\n\na2/a1\n\n [1] 2.000000 1.909091 1.833333 1.769231 1.714286 1.666667 1.625000 1.588235\n [9] 1.555556 1.526316 1.500000\n\na1^2*log(a2)\n\n [1]  299.5732  368.3872  445.1101  529.8985  622.8986  724.2471  834.0727\n [8]  952.4969 1079.6343 1215.5938 1360.4790",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#ouvrir-laide",
    "href": "vecteurs.html#ouvrir-laide",
    "title": "1  Découverte de R",
    "section": "1.4 Ouvrir l’aide",
    "text": "1.4 Ouvrir l’aide\nToutes les fonctions prédéfinies dans R possèdent une vignette (description des arguments de la fonction, des sorties et un exemple utilisant la fonction). Pour accéder à cette aide on met un point d’interrogation devant le nom de la fonction.\nExemple : Décrire la fonction sample\n\n?sample\n\nUne fonction comporte plusieurs arguments. Par exemple sample(x, size, replace = FALSE, prob = NULL)\nParmi les arguments, certains sont obligatoires\n\nx est un vecteur dans lequel on va choisir des valeurs au hasard.\nsize est la taille du résultat\n\nd’autres sont facultatifs (ils ont des valeurs par défaut) ici replace et prob.\n\nsample(-10:10,1)\n\n[1] 7\n\nsample(-10:10,3)\n\n[1]  5 -3  4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#un-peu-de-logique",
    "href": "vecteurs.html#un-peu-de-logique",
    "title": "1  Découverte de R",
    "section": "1.5 Un peu de logique",
    "text": "1.5 Un peu de logique\n\nl’opérateur | correspond à OU : A | B est faux lorsque les deux événements A et B sont faux simultanément et est vrai dans tous les autres cas.\nl’opérateur & correspond à ET : A & B est vrai uniquement lorsque les deux événements A et B sont vrais et est faux dans tous les autres cas.\n\nOn définit un vecteur\n\nset.seed(\"44\")\nx=sample(-20:20,40,T)\n\nOn veut savoir combien de valeurs de x sont postives.\n\nsum(x&gt;0)\n\n[1] 15\n\n\nQuelles sont les positions de ces valeurs ?\n\nwhich(x&gt;0)\n\n [1]  2  7  8 16 18 21 22 24 26 27 30 32 33 35 39\n\n\nQuels sont les indices des valeurs supérieure à 5 ou inférieure à 0 ?\n\nwhich(x&gt;5 | x&lt;0)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 14 15 16 17 18 19 22 23 24 25 26 27 28\n[26] 29 30 31 32 33 34 35 36 37 38 39 40\n\n\nQuels sont les indices des valeurs dans [5,10] ?\n\nwhich(x&gt;=5 & x&lt;=10)\n\n[1]  8 32 39",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "vecteurs.html#exercices",
    "href": "vecteurs.html#exercices",
    "title": "1  Découverte de R",
    "section": "1.6 Exercices",
    "text": "1.6 Exercices\n\n1.6.1 Exo 1 :\n\nCréer le vecteur x contenant le nom des villes suivantes Nantes, Brest, Rennes, Angers, Le Mans\n\n\n\nVoir la correction\n x&lt;-c(\"Nantes\", \"Brest\", \"Rennes\", \"Angers\",\"Le Mans\")\n\n\n\nAfficher le premier élément de x\n\n\n\nVoir la correction\nx[1]\n\n\n[1] \"Nantes\"\n\n\n\nAfficher tous les éléments de x sauf le premier\n\n\n\nVoir la correction\nx[-1]\n\n\n[1] \"Brest\"   \"Rennes\"  \"Angers\"  \"Le Mans\"\n\n\n\nAfficher les trois premiers éléments de x.\n\n\n\nVoir la correction\nx[1:3]\n\n\n[1] \"Nantes\" \"Brest\"  \"Rennes\"\n\n\n\nAfficher le deuxième et le quatrième élément de x.\n\n\n\nVoir la correction\nx[c(2,4)]\n\n\n[1] \"Brest\"  \"Angers\"\n\n\n\nClasser les éléments de x dans l’ordre alphabétique puis anti-alphabétique grâce aux fonctions sort et rev.\n\n\n\nVoir la correction\nsort(x)\n\n\n[1] \"Angers\"  \"Brest\"   \"Le Mans\" \"Nantes\"  \"Rennes\" \n\n\nVoir la correction\nrev(sort(x))\n\n\n[1] \"Rennes\"  \"Nantes\"  \"Le Mans\" \"Brest\"   \"Angers\" \n\n\n\n\n1.6.2 Exo 2 :\n\nCréer un vecteur \\(y\\) contenant les entiers pairs inférieurs à 100 grâce à la fonction seq.\n\n\n\nVoir la correction\ny&lt;-seq(2,100,by=2)\n\n\n\nAjouter à y les entiers impairs inférieurs à 100. On stockera la valeur obtenue dans une variable \\(S\\).\n\n\n\nVoir la correction\nz&lt;-seq(1,100,2)\nS&lt;-y+z\n\n\n\nDéterminer la taille du vecteur \\(S\\) final.\n\n\n\nVoir la correction\nlength(x)\n\n\n[1] 5\n\n\n\nA l’aide de la fonction rep créer un vecteur sonnette contenant 4 fois « ding » puis 4 fois « dong ».\n\n\n\nVoir la correction\nsonette&lt;-c(rep(\"ding\",4),rep(\"dong\",4))\n\n\n\nA l’aide de la fonction sample créer un vecteur melodie contenant une succession aléatoire de « ding » et de « dong » de taille 100.\n\n\n\nVoir la correction\nmelodie&lt;-sample(c(\"ding\",\"dong\"),100,replace=T)\n\n\n\nGrâce à la fonction table, déterminer combien il y a de « ding » et combien il y a de « dong » dans melodie.\n\n\n\nVoir la correction\ntable(melodie)\n\n\nmelodie\nding dong \n  51   49 \n\n\n\n\n1.6.3 Exo 3 :\n\nGénérer un vecteur \\(x\\) de taille 100 de valeurs tirées selon une loi normale centrée réduite (ie de paramètre 0 et 1) grâce à la fonction rnorm.\n\n\n\nVoir la correction\nx&lt;-rnorm(100)\n\n\n\nCalculer la somme et la moyenne de x à l’aide des fonctions dédiées.\n\n\n\nVoir la correction\nsum(x)\n\n\n[1] 6.836133\n\n\nVoir la correction\nmean(x)\n\n\n[1] 0.06836133\n\n\n\nCalculer le minimum, le premier quartile, la médiane, le troisième quartile et le maximum de \\(x\\). La fonction quantile bien utilisée vous donnera toutes ces informations directement…\n\n\n\nVoir la correction\nquantile(x)\n\n\n        0%        25%        50%        75%       100% \n-1.7635615 -0.4989122 -0.0209831  0.5305801  2.5839972 \n\n\n\nGénérer le vecteur booléen indiquant si les nombres contenus dans \\(x\\) sont positifs (TRUE) ou non (FALSE).\n\n\n\nVoir la correction\ny&lt;-(x&gt;0)\n\n\n\nMême question pour indiquer les nombres sont compris entre -1 et 1.\n\n\n\nVoir la correction\n(x&lt; -1)|(x&gt;1)\n\n\n  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n [13]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [25]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n [73] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n [85] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE\n\n\n\nAfficher les indices des valeurs négatives de x.\n\n\n\nVoir la correction\nwhich(x&lt;0)\n\n\n [1]  3  4  5  8  9 10 12 16 19 20 21 24 29 30 32 33 37 41 42 43 45 49 50 51 52\n[26] 53 54 57 59 61 62 63 64 65 68 70 72 73 76 80 81 82 83 85 86 92 93 94 95 97\n[51] 98\n\n\n\nAfficher la valeur absolue de \\(x\\).\n\n\n\nVoir la correction\nabs(x)\n\n\n  [1] 1.85574909 0.54117884 0.45518286 0.22270690 0.57108907 0.27666158\n  [7] 0.41737962 0.32542423 0.99543585 0.58250681 2.58399725 0.48327788\n [13] 1.51818339 0.55913559 0.20385387 0.30237005 1.76756778 1.75913010\n [19] 1.19442452 1.06333094 1.68238090 0.46061773 0.25167509 0.38374751\n [25] 1.77391253 0.47200392 2.06245528 0.25415520 0.38475149 0.29951813\n [31] 0.63689839 1.21737745 0.66784497 0.28300890 0.53015940 0.90172588\n [37] 0.88977916 0.26542640 0.50075054 0.87440431 0.25863208 0.28193896\n [43] 0.86484487 1.04268008 0.71038537 0.86695391 0.14066352 0.48631277\n [49] 0.03093615 0.20029344 0.69075871 0.13886615 0.94497593 0.93471341\n [55] 1.66707572 0.31637381 0.13833978 0.09110898 0.08448024 0.72501472\n [61] 0.18990729 0.28831530 0.51306150 0.70779990 1.07960193 1.63857250\n [67] 1.62068549 1.50606598 0.61691182 1.76356145 0.78406055 1.67097020\n [73] 0.49419582 1.11009853 0.14399290 0.37416729 0.07630757 0.37620167\n [79] 0.18043558 0.01103006 1.73299653 1.10352414 0.09230857 0.68936825\n [85] 0.57227810 0.30629490 0.04290168 1.78154160 0.53184204 2.37923900\n [91] 0.38853313 1.21706843 0.09963849 0.42988531 0.17272274 0.51102030\n [97] 0.45067615 0.76971246 0.15956416 0.26473857\n\n\n\nAfficher la partie entière des valeurs de x.\n\n\n\nVoir la correction\nfloor(x)\n\n\n  [1]  1  0 -1 -1 -1  0  0 -1 -1 -1  2 -1  1  0  0 -1  1  1 -2 -2 -2  0  0 -1  1\n [26]  0  2  0 -1 -1  0 -2 -1  0  0  0 -1  0  0  0 -1 -1 -1  1 -1  0  0  0 -1 -1\n [51] -1 -1 -1 -1  1  0 -1  0 -1  0 -1 -1 -1 -1 -2  1  1 -2  0 -2  0 -2 -1  1  0\n [76] -1  0  0  0 -1 -2 -2 -1  0 -1 -1  0  1  0  2  0 -2 -1 -1 -1  0 -1 -1  0  0\n\n\n\nAfficher uniquement les valeurs positives de x.\n\n\n\nVoir la correction\nx[x&gt;0]\n\n\n [1] 1.85574909 0.54117884 0.27666158 0.41737962 2.58399725 1.51818339\n [7] 0.55913559 0.20385387 1.76756778 1.75913010 0.46061773 0.25167509\n[13] 1.77391253 0.47200392 2.06245528 0.25415520 0.63689839 0.28300890\n[19] 0.53015940 0.90172588 0.26542640 0.50075054 0.87440431 1.04268008\n[25] 0.86695391 0.14066352 0.48631277 1.66707572 0.31637381 0.09110898\n[31] 0.72501472 1.63857250 1.62068549 0.61691182 0.78406055 1.11009853\n[37] 0.14399290 0.07630757 0.37620167 0.18043558 0.68936825 0.04290168\n[43] 1.78154160 0.53184204 2.37923900 0.38853313 0.51102030 0.15956416\n[49] 0.26473857\n\n\n\nRemplacer les valeurs négatives de x par 0. Vérifier le remplacement.\n\n\n\nVoir la correction\nx[x&gt;0]&lt;-0\nx\n\n\n  [1]  0.00000000  0.00000000 -0.45518286 -0.22270690 -0.57108907  0.00000000\n  [7]  0.00000000 -0.32542423 -0.99543585 -0.58250681  0.00000000 -0.48327788\n [13]  0.00000000  0.00000000  0.00000000 -0.30237005  0.00000000  0.00000000\n [19] -1.19442452 -1.06333094 -1.68238090  0.00000000  0.00000000 -0.38374751\n [25]  0.00000000  0.00000000  0.00000000  0.00000000 -0.38475149 -0.29951813\n [31]  0.00000000 -1.21737745 -0.66784497  0.00000000  0.00000000  0.00000000\n [37] -0.88977916  0.00000000  0.00000000  0.00000000 -0.25863208 -0.28193896\n [43] -0.86484487  0.00000000 -0.71038537  0.00000000  0.00000000  0.00000000\n [49] -0.03093615 -0.20029344 -0.69075871 -0.13886615 -0.94497593 -0.93471341\n [55]  0.00000000  0.00000000 -0.13833978  0.00000000 -0.08448024  0.00000000\n [61] -0.18990729 -0.28831530 -0.51306150 -0.70779990 -1.07960193  0.00000000\n [67]  0.00000000 -1.50606598  0.00000000 -1.76356145  0.00000000 -1.67097020\n [73] -0.49419582  0.00000000  0.00000000 -0.37416729  0.00000000  0.00000000\n [79]  0.00000000 -0.01103006 -1.73299653 -1.10352414 -0.09230857  0.00000000\n [85] -0.57227810 -0.30629490  0.00000000  0.00000000  0.00000000  0.00000000\n [91]  0.00000000 -1.21706843 -0.09963849 -0.42988531 -0.17272274  0.00000000\n [97] -0.45067615 -0.76971246  0.00000000  0.00000000",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Découverte de R</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Preface\nBref historique :",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#fichiers-gérés-par-r",
    "href": "index.html#fichiers-gérés-par-r",
    "title": "Introduction à R",
    "section": "Fichiers gérés par R",
    "text": "Fichiers gérés par R\n\nLes scripts (fichiers .R) : ils vont contenir les codes R ainsi que des commentaires sur ces codes (très importants par la suite).\nLes environnements (fichiers .RData) qui seront des ensembles d’objets.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#interfaces-de-r",
    "href": "index.html#interfaces-de-r",
    "title": "Introduction à R",
    "section": "Interfaces de R :",
    "text": "Interfaces de R :\n\nLa basique : Rgui (déconseillée) composée d’une fenêtre principale appelée la Console à partir de laquelle on exécute les fonctions.\nRStudio : interface graphique utilisée.\n\n\n\n\nRStudio",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#les-librairies-de-r-ou-packages",
    "href": "index.html#les-librairies-de-r-ou-packages",
    "title": "Introduction à R",
    "section": "Les librairies de R (ou packages)",
    "text": "Les librairies de R (ou packages)\nDe très nombreux packages ont été développés pour R, ils permettent d’ajouter de nouvelles fonctionnalités. Pour installer un package on va dans Tools -&gt; Install Packages\n\n\n\nInstaller un package\n\n\nPar exemple (ne le faites pas ) on installe le package equivalence, ce qui est très important c’est qu’il faut demander à R installer toutes les dépendances du package. Ensuite il faut absolument charger le package dans le script pour pouvoir l’utiliser.\n\nlibrary(equivalence)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#installer-r-et-rstudio",
    "href": "index.html#installer-r-et-rstudio",
    "title": "Introduction à R",
    "section": "Installer R et RStudio",
    "text": "Installer R et RStudio\nLes deux logiciels sont disponiles à l’adresse https://posit.co/download/rstudio-desktop/ et peuvent s’installer sur Windows, Mac ou Linux.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#premiers-pas-dans-r",
    "href": "index.html#premiers-pas-dans-r",
    "title": "Introduction à R",
    "section": "Premiers pas dans R",
    "text": "Premiers pas dans R\nDans la console exécuter les lignes suivantes :\n\n1 + 1\n\n[1] 2\n\npi\n\n[1] 3.141593\n\nsin(0)\n\n[1] 0\n\nsin(3*pi/2)\n\n[1] -1\n\n\nA partir de maintenant toutes les commandes seront enregistrées dans un fichier script que vous nommerez TD1.R Pour ce faire : File -&gt; New File -&gt; R Script\nLa plupart des fonctions mathématiques sont définies dans R (library base)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#les-variables",
    "href": "index.html#les-variables",
    "title": "Introduction à R",
    "section": "Les variables",
    "text": "Les variables\nUne variable est un objet référencé dans le programme qui associe un identificateur à une valeur d’un certain type.\n\nL’identificateur est le nom de la variable utilisé pour l’appeler,\nLa valeur est ce que contient la variable,\nLe type est l’ensemble dans lequel la variable prend sa valeur.\n\n\nx=2\nprint(x)\n\n[1] 2\n\nmode(x)\n\n[1] \"numeric\"\n\n## Supprimer x\nrm(x)\n\nLes variables contenant des caractères (on utilise ““)\n\nx&lt;-\"bonjour\"\nprint(x)\n\n[1] \"bonjour\"\n\nmode(x)\n\n[1] \"character\"\n\n\nLes variables contenant des booléens (vrai ou faux)\n\nx&lt;-TRUE\nprint(x)\n\n[1] TRUE\n\nmode(x)\n\n[1] \"logical\"",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "programmer.html",
    "href": "programmer.html",
    "title": "6  Programmer sur R",
    "section": "",
    "text": "6.1 Instructions conditionnelles :\nif(condition){instruction} permet de calculer des instructions uniquement lorsque la condition est vraie.\nRegarder l’aide des fonctions runif et paste pour comprendre ce qu’elles retournent.\nx&lt;-runif(1,-10,10)\nif(x&gt;0){print(paste(\"La valeur\",round(x,1),\"est positive\",sep=\" \"))}\nif(condition){instruction1}else{instruction2} permet de calculer l’instruction1 lorsque la condition est vraie et l’instruction2 lorsque la condition est fausse.\nx&lt;-runif(1,-10,10)\nif(x&gt;0){\n  print(paste(\"La valeur\",round(x,1),\"est positive\",sep=\" \"))}else{\n  print(paste(\"La valeur\",round(x,1),\"est négative\",sep=\" \"))}\n\n[1] \"La valeur -0.5 est négative\"\nOn peut imbriquer plusieurs conditions if.\nRappel :\nExercice :\nVoir la correction\nx&lt;-runif(1,0,10)\ny&lt;-runif(1,0,10)\nif(x&lt;y){z&lt;-x+1}else if(x&gt;5 & y&gt;5){z&lt;-x+2}else{z&lt;-x} \nprint(paste(\"x=\",x,\"y=\",y,\"z=\",z))\n\n\n[1] \"x= 6.58076351508498 y= 6.53117741690949 z= 8.58076351508498\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Programmer sur R</span>"
    ]
  },
  {
    "objectID": "programmer.html#instructions-conditionnelles",
    "href": "programmer.html#instructions-conditionnelles",
    "title": "6  Programmer sur R",
    "section": "",
    "text": "l’opérateur | correspond à OU : A | B est faux lorsque les deux événements A et B sont faux simultanément.\nl’opérateur & correspond à ET : A & B est vrai uniquement lorsque les deux événements A et B sont vrais.\n\n\n\nChoisir deux nombres \\(x,y\\) au hasard dans l’intervalle \\([0,10]\\)\nLa valeur stockée dans la variable \\(z\\) sera égale à \\(x+1\\) si \\(x&lt;y\\) sinon égale à \\(x+2\\) si \\(x&gt;5\\) et \\(y&gt;5\\) sinon égale à \\(x\\).\nRetourner les valeurs de x,y,z. On pourra utiliser la fonction paste().",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Programmer sur R</span>"
    ]
  },
  {
    "objectID": "programmer.html#boucle-for-while",
    "href": "programmer.html#boucle-for-while",
    "title": "6  Programmer sur R",
    "section": "6.2 Boucle FOR, WHILE :",
    "text": "6.2 Boucle FOR, WHILE :\n\n6.2.1 FOR\nfor (var in seq) {commandes} permet de définir un nombre d’itérations dans une séquence.\nPar exemple on veut Stocker dans la variable x la somme des entiers de 1 à n où n est fixé par l’utilisateur :\n\nn&lt;-100\nx&lt;-0\nfor(i in 1:n){x&lt;-x+i}\nprint(x)\n\n[1] 5050\n\n\nMais on peut aussi faire la somme de tous les entiers impairs compris entre 1 et n\n\nn&lt;-100\nx&lt;-0\nimpairs&lt;-seq(1,n,2)\nfor(i in impairs){x&lt;-x+i}\nprint(x)\n\n[1] 2500\n\n\nExercice : On considère deux variables \\(x,y\\) initialisées à 0. On propose le jeu suivant : “à chaque itération on tire un nombre au hasard entre 0 et 1, lorsque ce nombre est supérieur à 0.5 on incrémente la valeur précédente de \\(y\\) de 1, sinon c’est la valeur précédente de \\(x\\) qui est incrémentée de 1.”\nLe joueur gagne si au bout de \\(n\\) itérations \\(y&gt;x.\\) Ecrire le programme pour \\(n=10.\\)\n\n\nVoir la correction\nn&lt;-10\ny=x=0\nfor(i in 1:n){\na&lt;-runif(1,0,1)\nif(a&gt;0.5){y&lt;-y+1}else{x&lt;-x+1}\n}\nif(y&gt;x){print(\"Gagnant\")}else{print(\"Perdant\")}\n\n\n[1] \"Perdant\"\n\n\n\n\n6.2.2 WHILE\nwhile(condition){instruction} répète une instruction tant que la condition considérée est vraie. Attention, la condition est évaluée avant toute exécution dans while.\n\ni&lt;-1\nwhile (i&lt;10){\n   print(i)\n   i=i+1}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n\n\nExercice\n\nCréer un vecteur nommé vecAlea de 100 valeurs entières entre 1 et 100. On utilisera la fonction sample avec remise.\n\n\n\ndéterminer le vecteur IND qui contient les indices des valeurs strictement supérieures à 50, (avec une boucle et sans une boucle)\ndéterminer le vecteur VEC contenant ces valeurs.\n\n\n\nOn calcule le maximum du vecteur vecAlea. Déterminer à l’aide d’une boucle le nombre de fois où ce maximum apparaît dans vecAlea. Retrouver ce nombre sans utiliser de boucle.\nCréer le vecteur nommé vecPM5 contenant tous les nombres de 1 à 100 qui ne sont pas des multiples de 5 (avec une boucle puis sans). Penser à la fonction floor qui calcule la partie entière.\n\n\n\nVoir la correction\nvecAlea&lt;-sample(1:100,100,T)\n## Q1\n## AVEC la boucle\nIND&lt;-c()\nfor(i in 1:100){ \n  if(vecAlea[i]&gt;50){IND&lt;-c(IND,i)}\n  }\n\n# SANS LA BOUCLE\nIND&lt;-which(vecAlea&gt;50)\n\nVEC&lt;-vecAlea[IND]\n\n## Q2 \nM&lt;-max(vecAlea)\n\nIND_M&lt;-c()\nfor(i in 1:100){ \n  if(vecAlea[i]==M){IND_M&lt;-c(IND_M,i)}\n  }\nlength(IND_M)\n\n\n[1] 3\n\n\nVoir la correction\nlength(which(vecAlea==M))\n\n\n[1] 3\n\n\nVoir la correction\n## Q3\nx&lt;-c()\ni&lt;-1\nwhile(i&lt;=100){\n  if(i/5-floor(i/5)&gt;0){x&lt;-c(x,i)}else{x&lt;-x}\n  i&lt;-i+1\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Programmer sur R</span>"
    ]
  },
  {
    "objectID": "programmer.html#ecrire-une-fonction-en-r",
    "href": "programmer.html#ecrire-une-fonction-en-r",
    "title": "6  Programmer sur R",
    "section": "6.3 Ecrire une fonction en R :",
    "text": "6.3 Ecrire une fonction en R :\nOn veut écrire une fonction qui étant donnée le rayon \\(r\\) d’un cercle permet de calculer son périmètre \\(P=2\\pi r\\), on note cette fonction perim()\n\nperim&lt;-function(r){\n  return(2*pi*r)\n}\nperim(1)\n\n[1] 6.283185\n\n\nOn remarque que dans le langage R il n’est pas nécessaire de donner le type des arguments (entier, carcatère,…) la fonction s’appliquera sauf si le type n’est pas correct\n\nperim(\"rayon\")\n\nOn peut améliorer cette fonction en indiquant à l’utilisateur que la fonction ne sera calculée que lorsque \\(r&gt;0\\) :\n\n\nVoir la correction\nperim&lt;-function(r){\n  if(r&gt;0){return(2*pi*r)}else{return(\"On ne calcule le périmètre que lorsque r&gt;0\")}\n}\nperim(1)\n\n\n[1] 6.283185\n\n\nVoir la correction\nperim(-1)\n\n\n[1] \"On ne calcule le périmètre que lorsque r&gt;0\"\n\n\nPar contre l’erreur reste identique si on applique la fonction périmètre à “rayon”. On peut également définir des fonctions qui ont plusieurs arguments en entrée et qui peuvent retourner plusieurs valeurs en sortie.\nAutre Exemple : On va écrire une fonction restangle() ayant pour arguments L et l qui renvoie le périmètre \\(P=2\\times(L+l)\\) et l’aire \\(A=L\\times l\\) du rectangle.\n\n\nVoir la correction\nrectangle&lt;-function(L,l){\n  P=2*(L+l)\n  A=L*l\n  return(list(Perim=P,Aire=A))\n}\nrectangle(11,10)\n\n\n$Perim\n[1] 42\n\n$Aire\n[1] 110\n\n\nVoir la correction\n## Que le périmètre :\nrectangle(11,10)$Perim\n\n\n[1] 42\n\n\nExercice :\nCréér une fonction SomEnt() ayant pour argument un nombre entier n et qui retourne la somme des entiers inférieurs à n.\n\n\nVoir la correction\nSomEnt&lt;-function(n){\n  x&lt;-0\n  for(i in 1:n) x&lt;-x+i\n  return(x)\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Programmer sur R</span>"
    ]
  },
  {
    "objectID": "programmer.html#exercices",
    "href": "programmer.html#exercices",
    "title": "6  Programmer sur R",
    "section": "6.4 Exercices :",
    "text": "6.4 Exercices :\n\n6.4.1 Exercice 1 (Droite des moindres carrés)\nOn va écrire une fonction R qui permet de déterminer la droite des moindres carrées ordinaires. Vous verrez (ultérieurment en stat) que pour un nuage de points \\((x_i,y_i)_{i=1,...,n}\\) la droite la plus proche (au sens des moindres carées) de ce nuage a pour pente \\(b=\\frac{\\frac{1}{n}\\sum{x_i y_i}-\\bar x\\bar y}{\\frac{1}{n}\\sum x_i^2-\\bar x}\\) et pour ordonnée à l’origine \\(a=\\bar y -b \\bar x.\\)\nCréer une fonction nommée droite() ayant pour arguments deux vecteurs x,y et qui calcule le coefficient directeur de la droite et son ordonnée à l’origine.\n\n\nVoir la correction\ndroite&lt;-function(x,y){\n  b&lt;-(mean(x*y)-mean(x)*mean(y))/(mean((x-mean(x))^2))\n  a&lt;-mean(y)-b*mean(x)\n  return(list(a=a,b=b))\n}\n\n\n\n\n6.4.2 Exercice 2 : Boucles et graphiques\nOn charge les packages suivants pour réaliser les manipulations sur les graphes :\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nReprendre la base de données iris :\n\ndata(\"iris\")\n\n\nUtiliser une boucle de manière à faire une boîte à moustaches par variable quantitative Sepal.Length, Sepal.Width, Petal.Length, Petal.Width selon l’espèce Species. Le mieux est de définir un objet liste dans lequel chacun des graphiques sera stocké et ensuite on utilisera la fonction grid.arrange du package gridExtra\n\n\n\nVoir la correction\ngraph&lt;-list()\n\nfor(i in 1:4){\n  data=data.frame(Species=iris$Species,y=iris[,i])\n  graph[[i]]&lt;-ggplot(data,aes(x=Species,y=y))+\n    geom_boxplot()+\n    labs(y=colnames(iris)[i])+\n    geom_hline(yintercept = mean(iris[,i]),linetype=\"dashed\",color=\"red\")\n}\ngridExtra::grid.arrange(grobs=graph,ncol=2,nrow=2)\n\n\n\n\n\n\n\n\n\n\nUtiliser une boucle de reproduire le graphique suivant (on pensera à utiliser la fonction abline pour ajouter la droite des moindres carrés):\n\n\n\nVoir la correction\ngraph&lt;-list()\nespeces&lt;-levels(iris$Species)\n\nfor(i in 1:3){\n    data=iris%&gt;%filter(Species==especes[i])\n    D&lt;-droite(data$Sepal.Length,data$Sepal.Width)\n   graph[[i]]&lt;- ggplot(data,aes(x=Sepal.Length,y=Sepal.Width))+\n      geom_point()+\n      geom_abline(slope=D$b,intercept = D$a,color=\"red\")+\n     annotate(\"text\", label =paste(\"y=\",round(D$b,2),\"x+\",round(D$a,2),sep=\"\"),\n    x = mean(data$Sepal.Length), y = max(data$Sepal.Width), size = 6, colour = \"red\"\n  )\n}\ngridExtra::grid.arrange(grobs=graph,ncol=3)\n\n\n\n\n\nTrois graphes différents\n\n\n\n\n\nRéaliser le graphe suivant qui réunit les trois précédents sur un même graphique (on utilisera la fonction geom_smooth avec method=“lm”).\n\n\nggplot(iris,aes(x=Sepal.Length,y=Sepal.Width,shape=Species,color=Species))+\n  geom_point()+\n    geom_smooth(method=\"lm\",se = FALSE) \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nTrois graphes dans le même environnement",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Programmer sur R</span>"
    ]
  },
  {
    "objectID": "manipulation_df.html",
    "href": "manipulation_df.html",
    "title": "4  Manipulations data-frame",
    "section": "",
    "text": "4.1 Le pipe\nLe pipe |&gt; natif de R ou bien le pipe de la librairie dplyr permettent d’enchainer une suite de calcul.\nPar exemple, on veut calculer la moyenne de la colonne mpg pour les voitures qui ont 6 cylindres et qui sont automatiques (mtcars) :\ndata(\"mtcars\")\nmean(mtcars[mtcars$cyl==6 & mtcars$am==1,\"mpg\"])\n\n[1] 20.56667\nce qui donne avec le pipe :\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nmtcars |&gt;\n  filter(cyl==6 & am==1) |&gt;\n  select(mpg) |&gt;\n  unlist() |&gt;\n  mean()\n\n[1] 20.56667\nLa fonction unlist permet de transformer la colonne obtenue par select.\nLe pipe revient donc à enchainer des fonctions.\nLe package dplyr possède de nombreuses fonctions permettant de faire de la gestion de données :",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulations data-frame</span>"
    ]
  },
  {
    "objectID": "manipulation_df.html#le-pipe",
    "href": "manipulation_df.html#le-pipe",
    "title": "4  Manipulations data-frame",
    "section": "",
    "text": "select, pour sélectionner des colonnes\nfilter, pour filtrer des lignes selon un (ou plusieurs) critère.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulations data-frame</span>"
    ]
  },
  {
    "objectID": "manipulation_df.html#la-fonction-mutate",
    "href": "manipulation_df.html#la-fonction-mutate",
    "title": "4  Manipulations data-frame",
    "section": "4.2 La fonction mutate()",
    "text": "4.2 La fonction mutate()\nElle permet de définir de nouvelles colonnes dans un data frame qui seront le résultat d’un calcul. Par exemple la consommation des voitures est exprimée en mpg (miles per galon) si on veut l’exprimer en L/100km alors on utilise (L/100 km) = 282.48 / MPG\n\nmtcars&lt;-mtcars |&gt;\n  mutate(\"L/100km\"=282.48/mpg) |&gt;\n  round(digits = 1)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulations data-frame</span>"
    ]
  },
  {
    "objectID": "manipulation_df.html#group_by-summarise",
    "href": "manipulation_df.html#group_by-summarise",
    "title": "4  Manipulations data-frame",
    "section": "4.3 group_by(), summarise()",
    "text": "4.3 group_by(), summarise()\nLa fonction group_by() permettra de faire des calculs selon les modalités d’une variable qualitative :\n\ndf=mtcars |&gt;\n  group_by(cyl,am) |&gt;\n  summarise(M=mean(`L/100km`),SD=sd(`L/100km`))\n\n`summarise()` has grouped output by 'cyl'. You can override using the `.groups`\nargument.\n\ndf\n\n# A tibble: 6 × 4\n# Groups:   cyl [3]\n    cyl    am     M    SD\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     4     0  12.4 0.751\n2     4     1  10.3 1.76 \n3     6     0  14.8 1.21 \n4     6     1  13.8 0.462\n5     8     0  19.4 4.08 \n6     8     1  18.4 0.636\n\n\nLe résultat est un nouveau data frame dans le format tibble que l’on peut utiliser ensuite dans ggplot par exemple.\n\nlibrary(ggplot2)\nggplot(df,aes(x=factor(cyl),y=M,color=factor(am)))+\n  geom_point(position = position_dodge(.2))+\n  geom_errorbar(aes(ymin=M-2*SD,ymax=M+2*SD),width=.1,position = position_dodge(.2))",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulations data-frame</span>"
    ]
  }
]