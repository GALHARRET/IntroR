{
  "hash": "a08473d67b540a76d99aed004b425ace",
  "result": {
    "markdown": "# Premières commandes\n\nDans la console exécuter les lignes suivantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1\npi\nsin(0)\nsin(3*pi/2)\n```\n:::\n\n\nA partir de maintenant toutes les commandes seront enregistrées dans un fichier script que vous nommerez TD1.R Pour ce faire : File -\\> New File -\\> R Script\n\nLa plupart des fonctions mathématiques sont définies dans R (library base)\n\n# La définition des variables\n\nUne variable est un objet référencé dans le programme qui associe un identificateur à une valeur d'un certain type.\n\n-   ***L'identificateur*** est le nom de la variable utilisé pour l'appeler,\n-   ***La valeur*** est ce que contient la variable,\n-   ***Le type*** est l'ensemble dans lequel la variable prend sa valeur.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx=2\nprint(x)\nmode(x)\n## Supprimer x\nrm(x)\n```\n:::\n\n\n\nLes variables contenant des caractères (on utilise \"\")\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-\"bonjour\"\nprint(x)\nmode(x)\n```\n:::\n\n\n\nLes variables contenant des booléens (vrai ou faux)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-TRUE\nprint(x)\nmode(x)\n```\n:::\n\n\n\n\n# Les vecteurs\n\n-   Un des objets de base de R\n-   toutes les valeurs de même type (nombre, chaine de caractères, booléen)\n-   création via la fonction c() \\[combine\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1<-c(1.5,2,3.2,-1.5,0,-1)\na2<-c(\"fille\",\"garçon\",\"fille\",\"fille\",\"fille\",\"fille\")\na3<-c(TRUE,FALSE,TRUE,TRUE)\n```\n:::\n\n\nOn peut déterminer la nature du vecteur en utilisant class() :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(a1)\nclass(a2)\nclass(a3)\n```\n:::\n\n\n***Exercice :***\n\n1)  Combiner les vecteurs a1 et a2 dans un nouveau vecteur a.\n\n2)  Quelle est la classe du résultat ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\na<-c(a1,a2)\nclass(a)\n```\n:::\n\n\n-   ***rep*** permet d'écrire n fois la valeur a : rep(a,n)\n\n\n***Exercice :*** créer un vecteur avec 5 fois fille et 10 fois garçon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(5,10)\nrep(\"fille\",10)\n```\n:::\n\n\n-   ***seq*** définit une séquence de nombre entre MIN et MAX avec un pas de L : seq(MIN,MAX,by=L)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(0,1,by=0.1)\nseq(10,20,by=5)\n```\n:::\n\n\n## Indexation et longueur d'un vecteur\n\nLa fonction length() permet de calculer le nombre de valeurs d'un vecteur (quelle que soit la nature du vecteur considéré).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(a1)\nlength(a2)\n```\n:::\n\n\nChaque élément d'un vecteur est repéré par un indice entre \\[\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1[1]\na1[3]\n# Opérations sur les éléments d'un vecteur\na1[1]+a1[3]\na1[1]/a1[3]\n```\n:::\n\n\nOn peut changer la valeur de a1\\[3\\] en lui affectant une nouvelle valeur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1[3]<- -3\na1\n```\n:::\n\n\nOn peut aussi ajouter de nouvelles valeurs aux vecteurs a1\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1[12]<-10\na1[13]<-11\n```\n:::\n\n\n## Les calculs de base avec un vecteur\n\nOn peut ajouter, soustraire, multiplier des vecteurs entre eux à condition qu'ils soient de même longeur et qu'ils soient numériques.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1<-seq(10,20,by=1)\na2<-seq(20,30,by=1)\na1+a2\na2-a1\na1*a2\na2/a1\na1^2*log(a2)\n```\n:::\n\n\n## Ouvrir l'aide\n\nToutes les fonctions prédéfinies dans R possèdent une vignette (description des arguments de la fonction, des sorties et un exemple utilisant la fonction). Pour accéder à cette aide on met un point d'interrogation devant le nom de la fonction.\n\n***Exemple : Décrire la fonction sample***\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?sample\n```\n:::\n\n\nUne fonction comporte plusieurs arguments. Par exemple ***sample(x, size, replace = FALSE, prob = NULL)***\n\nParmi les arguments, certains sont obligatoires\n\n-   x est un vecteur dans lequel on va choisir des valeurs au hasard.\n-   size est la taille du résultat\n\nd'autres sont facultatifs (ils ont des valeurs par défaut) ici replace et prob.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(-10:10,1)\nsample(-10:10,3)\n```\n:::\n\n\n## Un peu de logique\n\n1. l'opérateur | correspond à OU : A | B est faux lorsque les deux événements A et B sont faux simultanément et est vrai dans tous les autres cas.\n\n2. l'opérateur & correspond à ET : A & B est vrai uniquement lorsque les deux événements A et B sont vrais et est faux dans tous les autres cas.\n\nOn définit un vecteur\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(\"44\")\nx=sample(-20:20,40,T)\n```\n:::\n\n\nOn veut savoir combien de valeurs de x sont postives.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x>0)\n```\n:::\n\n\nQuelless sont les positions de ces valeurs ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(x>0)\n```\n:::\n\n\nQuels sont les indices des valeurs supérieure à 5 ou inférieure à 0 ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(x>5 | x<0)\n```\n:::\n\n\nQuels sont les indices des valeurs dans \\[5,10\\] ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(x>=5 & x<=10)\n```\n:::\n\n\n## Exercices\n\n### Exo 1 :\n\n1.  Créer le vecteur x contenant le nom des villes suivantes Nantes, Brest, Rennes, Angers, Le Mans\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\n x<-c(\"Nantes\", \"Brest\", \"Rennes\", \"Angers\",\"Le Mans\")\n```\n:::\n\n\n\n2.  Afficher le premier élément de x\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[1]\n```\n:::\n\n\n3.  Afficher tous les éléments de x sauf le premier\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[-1]\n```\n:::\n\n\n\n4.  Afficher les trois premiers éléments de x.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[1:3]\n```\n:::\n\n\n\n5.  Afficher le deuxième et le quatrième élément de x.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[c(2,4)]\n```\n:::\n\n\n\n6.  Classer les éléments de x dans l'ordre alphabétique puis anti-alphabétique grâce aux fonctions sort et rev.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsort(x)\nrev(sort(x))\n```\n:::\n\n\n\n### Exo 2 :\n\n1.  Créer un vecteur $y$ contenant les entiers pairs inférieurs à 100 grâce à la fonction seq.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ny<-seq(2,100,by=2)\n```\n:::\n\n\n\n2.\tAjouter à y les entiers impairs inférieurs à 100. On stockera la valeur obtenue dans une variable $S$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nz<-seq(1,100,2)\nS<-y+z\n```\n:::\n\n\n\n3.  Déterminer la taille du vecteur $S$ final.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nlength(x)\n```\n:::\n\n\n\n4.  A l'aide de la fonction rep créer un vecteur sonnette contenant 4 fois « ding » puis 4 fois « dong ».\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsonette<-c(rep(\"ding\",4),rep(\"dong\",4))\n```\n:::\n\n\n\n5.  A l'aide de la fonction sample créer un vecteur melodie contenant une succession aléatoire de « ding » et de « dong » de taille 100.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nmelodie<-sample(c(\"ding\",\"dong\"),100,replace=T)\n```\n:::\n\n\n\n6.  Grâce à la fonction table, déterminer combien il y a de « ding » et combien il y a de « dong » dans melodie.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ntable(melodie)\n```\n:::\n\n\n### Exo 3 :\n\n1. Générer un vecteur $x$ de taille 100 de valeurs tirées selon une loi normale centrée réduite (ie de paramètre 0 et 1) grâce à la fonction ***rnorm***.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx<-rnorm(100)\n```\n:::\n\n\n\n2. Calculer la somme et la moyenne de x à l’aide des fonctions dédiées.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsum(x)\nmean(x)\n```\n:::\n\n\n3. Calculer le minimum, le premier quartile, la médiane, le troisième quartile et le maximum de\n$x$. La fonction quantile bien utilisée vous donnera toutes ces informations directement...\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nquantile(x)\n```\n:::\n\n\n4. Générer le vecteur booléen indiquant si les nombres contenus dans $x$ sont positifs (TRUE) ou non (FALSE).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ny<-(x>0)\n```\n:::\n\n\n5. Même question pour indiquer les nombres sont compris entre -1 et 1.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\n(x< -1)|(x>1)\n```\n:::\n\n\n6. Afficher les indices des valeurs négatives de x.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nwhich(x<0)\n```\n:::\n\n\n7. Afficher la valeur absolue de $x$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nabs(x)\n```\n:::\n\n\n8. Afficher la partie entière des valeurs de x.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nfloor(x)\n```\n:::\n\n\n9. Afficher uniquement les valeurs positives de x.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[x>0]\n```\n:::\n\n\n10. Remplacer les valeurs négatives de x par 0. Vérifier le remplacement.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nx[x>0]<-0\nx\n```\n:::\n\n\n\n\n\n# Les matrices\n\nLes matrices sont comme en mathématiques des tableaux de données. Attention comme pour les vecteurs les matrices ne contiendront que des éléments du même type (numérique, texte, booléen).\n\n## Définition et fonctions de base\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA=matrix(c(1,2,3,\n           2,1,-1,\n           -3,-1,1),nrow=3)\n```\n:::\n\n\nQuelques fonctions utiles la dimension de la matrice\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(A)\n```\n:::\n\n\nLe résultat est donc un vecteur ayant deux éléments le nombre de ligne et le nombre de colonnes\n\n\n## Indexation des éléments d'une matrice\n\nLes éléments d'une matrice sont identifiés par un numéro de ligne et de colonne entre crochets A\\[i,j\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[1,2]\n# première ligne de A \nA[1,]\n# première colonne de A\nA[,1]\n```\n:::\n\n\n## Exercice :\n\n1. Générer un vecteur fillmat contenant 250 valeurs tirées selon une loi uniforme continue de paramètres 0 et 10 grâce à la fonction ***runif***.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nfillmat<-runif(250,0,10)\n```\n:::\n\n\n2. Créer une matrice Mesures de 50 lignes et 5 colonnes contenantes les valeurs de fillmat. Les colonnes seront nommées Mesure1,..., Mesure5.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nMesures<-matrix(fillmat,nrow=50)\ncolnames(Mesures)<-paste(\"Mesure\",1:5,sep=\"\")\n```\n:::\n\n\n3. Créer un vecteur Groupe de taille 50 contenant des valeurs entières entre 1 et 5 (fonction ***sample***). On interprétera Groupe comme le groupe d’appartenance des 50 lignes de Mesures. Ajouter cette colonne à la matrice Mesures.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nGroupe<-sample(1:5,50,replace=T)\nMesures$Groupe<-Groupe\n```\n:::\n\n\n\n4. Combien de lignes appartiennent au groupe n°2 ?\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsum(Groupe==2)\n```\n:::\n\n\n5. Afficher le numéro des lignes appartenant au groupe n°2.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nwhich(Groupe==2)\n```\n:::\n\n\n6. Afficher les lignes de Mesures correspondant au groupe n°2.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nMesures[groupe==2,]\n```\n:::\n\n\n7. Déterminer combien Mesures contient de valeurs inférieures à 5 (on exclura la colonne groupe du comptage).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsum(Mesures[,-6]<5)\n```\n:::\n\n\n8. Calculer la moyenne des valeurs de Mesures correspondant au groupe n°4.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nmean(Mesures[Groupe==4,])\n```\n:::\n\n\n9. Même question mais pour les 3 premières colonnes uniquement.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nmean(Mesures[Groupe==4,1:3])\n```\n:::\n\n\n\n10. Appliquer à Mesures les fonctions dim, ncol et nrow. A quoi correspondent ces nombres ?\n\n\n\n# Les data frames\n\nC'est l'objet le plus important et le plus utilisé dans R il s'agit d'un tableau de données mais contrairement aux matrices on peut avoir différents types de données dans un dataframe.\n\n## Création d'un data frame\n\nOn crée deux variables x et y contenant $n=100$ nombres distribués selon une loi uniforme continue sur \\[0,20\\] (fonction runif) et une variable gr (expliquer le résultat du code correspondant). La fonction ***round*** permet d'arrondir.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-round(runif(100,0,20),1)\ny<-round(runif(100,0,20),1)\ngr<-sample(c(\"ING1\",\"ING2\"),size=100,replace=T,prob=c(0.6,0.4))\ndf<-data.frame(NoteF=x,NoteM=y,gr=gr)\n```\n:::\n\n\nL'indexation des éléments dans un data-frame est la même que dans une matrice :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1,1]\n```\n:::\n\n\nOn peut également sélectionner une colonne du data frame via $\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$NoteF\n```\n:::\n\n\n## Les fonctions utiles pour les data frame\n\n### summary \n\nCette fonction permet de résumer l'ensemble des variables du data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n:::\n\n\n### apply\n\nLa fonction apply permet d'appliquer une fonction sur les lignes (1) ou les colonnes d'un data frame : par exemple si on souhaite appliquer la fonction moyenne (***mean***) sur les colonnes du data frame df on utilise :\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(df[,1:2],2,mean)\n```\n:::\n\nRemarque : on n'a utilisé que les deux premières colonnes du data frame car la troisième n'est pas numérique (donc on ne peut pas calculer sa moyenne).\n\n\n## Importation d'un data frame inclus dans un package\n\nPour accéder aux data frames de R :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata()\n```\n:::\n\n\nensuite on peut grâce à la fonction help obtenir de l'aide sur l'un des data frame :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(\"mtcars\")\n```\n:::\n\n\nEnsuite on charge le jeu de données via\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"mtcars\")\n```\n:::\n\n\nUne fois le data frame importé on constate qu'il est présent dans la fenêtre environnement\n\n![Fenêtre environnement](TD1_files/fig2.png)\n\n### La fonction factor()\n\nCette fonction va être très importante pour la suite et en particulier lorsque l'on va manipuler des jeux de donnnées en statistique.\n\nUn ***facteur*** est une variable qualitative. Les valeurs prises par  cette variable sont appelées ***modalités***. Il peut arriver que ces modalités soient codées. Par exemple dans certains jeux de données on connaîtra le statut professionnel des participants (modalités : en activité, en recherche d'emploi, étudiant, à la retraite) mais on peut avoir choisi de coder les modalités par des nombres (ici de 1 à 4) mais cette variable demeure un facteur.\n\nDans R :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstatut_pro<-sample(1:4,100,replace=T)\n## R ne voit pas qu'il s'agit d'un facteur car les modalités sont numériques\nclass(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntable(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstatut_pro\n 1  2  3  4 \n29 25 26 20 \n```\n:::\n:::\n\nOn utilise la fonction factor pour dire à R qu'il s'agit d'une variable qualitative. On voit le changement à travers class ou levels :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstatut_pro<-factor(statut_pro)\nclass(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nlevels(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\" \"4\"\n```\n:::\n\n```{.r .cell-code}\nlevels(statut_pro)<-c(\"en activité\", \"en recherche d'emploi\",\n                      \"étudiant\", \"à la retraite\")\ntable(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstatut_pro\n          en activité en recherche d'emploi              étudiant \n                   29                    25                    26 \n        à la retraite \n                   20 \n```\n:::\n:::\n\n***Remarque : *** Les variables binaires (facteurs à deux modalités) sont souvent codées 0/1.\n\nOn peut être amené à vouloir avoir les modalités d'un facteur classées dans un certain ordre pour ce faire on va utiliser la fonction labels avec l'ordre choisi :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstatut_pro<-factor(statut_pro,labels=c(\"étudiants\",\"en activité\",\n                                       \"en recherche d'emploi\",\"à la retraite\"))\ntable(statut_pro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstatut_pro\n            étudiants           en activité en recherche d'emploi \n                   29                    25                    26 \n        à la retraite \n                   20 \n```\n:::\n:::\n\n***Attention*** les labels doivent être exactement écrits de la même façon que les  levels si les modalités sont déjà écrites et sinon on peut directement agir sur les modalités via labels :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"mtcars\")\nhelp(\"mtcars\")\nmtcars$vs<-factor(mtcars$vs,levels=0:1,labels=c(\"V-shaped\",\"straight\"))\nmtcars$am<-factor(mtcars$am,levels=0:1,labels=c(\"automatic\",\"manual\"))\n```\n:::\n\n\n\n\n\n\n\n## Importation d'une base de données externe\n\nOn peut utiliser une interface graphique pour ouvrir les fichiers contenant le data frame. Les plus courants sont :\n\n-   \\*.csv : (Comma Separed Values) ce sont des fichiers de type tableaux sans mise en forme\n-   \\*.xlsx : fichiers produits à partir du logiciel excel\n-   \\*.ods : fichiers produits à partir du logiciel Calc de LibreOffice.\n\n![Menu Importer](TD1_files/fig3.png){width=\"250\"}\n\nOn va importer le data frame contenu dans le fichier bordeaux.csv disponible sur Connect (vous devez le télécharger).\n\n\nVous avez deux solutions : \n***From text (base)***\n\n![Importation avec la librairie base](TD1_files/fig4-0.png){width=100%}\n\n***From text (readr)***\n\n![Importation avec la librairie readr](TD1_files/fig4.png){height=75%}\n\nEnsuite il est recommandé de copier/coller la ligne de commande dans le script R afin de pas à avoir à reproduire la manipulation à chaque session de travail sur le fichier bordeaux.csv\n\n![La fonction read_csv()](TD1_files/fig5.png)\n\n\n## Exercice sur le data frame iris\n\n1.  Charger le fichier de données iris. Lire l'aide de iris pour comprendre le jeu de données.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ndata(\"iris\")\nhelp(\"iris\")\n```\n:::\n\n\n2.  Quel est le type de iris ? Quelles sont les dimensions de iris ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nclass(iris)\ndim(iris)\n```\n:::\n\n\n3.  Appliquer la fonction str à iris. A quoi correspondent les informations renvoyées ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nstr(iris)\n```\n:::\n\n\n4.  Appliquer la fonction summary à iris. A quoi correspondent les informations renvoyées ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsummary(iris)\n```\n:::\n\n\n5.  Utiliser les fonctions colnames() et rownames(). Quelles sont les informations renvoyées ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nrownames(iris)\n# Le nom des lignes de iris\ncolnames(iris)\n# Le nom des colonnes de iris\n```\n:::\n\n\n6.  A l'aide la fonction de texte paste remplacer le nom des lignes par fleur 1, ..., fleur 150.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nrownames(iris)<-paste(\"fleur\",1:150,sep=\" \")\n```\n:::\n\n\n7.  Pour un data frame on peut appeler une colonne par son nom en utilisant \\$ : iris\\$Sepal.Length. En utilisant cette information donner la classe de la colonne Species.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nclass(iris$Species)\n```\n:::\n\n\n8.  Quels sont les niveaux du facteur \"Species\" (fonction levels) ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nlevels(iris$Species)\n```\n:::\n\n\n9.  Créer une nouvelle colonne nommée groupe (on pensera à \\$) dans le data frame iris identique à la colonne Species. Quelle est la classe de cette nouvelle colonne ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\niris$groupe=iris$Species\nclass(iris$groupe)\n```\n:::\n\n\n10. Renommer les niveaux de la colonne groupe en A, B, C (A pour setosa, B pour versicolor, C pour virginica). Afficher les indices des lignes de iris correspondant au groupe B.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nlevels(iris$groupe)=c(\"A\",\"B\",\"C\")\nwhich(iris$groupe==\"B\")\n```\n:::\n\n\n11. Créer  l'ensemble des numéros de lignes correspondantes aux fleurs du groupe A. Afficher les lignes de iris correspondant au groupe A. Proposer une solution alternative.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nI=which(iris$groupe==\"A\")\niris[I,]\niris[iris$groupe==\"A\",]\n```\n:::\n\n\n12. En adoptant la même logique que la question précédente, afficher uniquement les lignes de iris où « Sepal.Length » est inférieur à 5.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\niris[iris$Sepal.Length<=5,]\n```\n:::\n\n\n13. Combien y a-t-il d'individus ayant la longueur des sépales inférieure à 5 ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsum(iris$Sepal.Length<=5)\n```\n:::\n\n\n## Exercice sur le data frame mtcars \n\n1.  Charger le data frame mtcars. Combien de véhicules et de caractéristiques sur les véhicules sont contenus dans le data frame ?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ndata(\"mtcars\")\nhelp(\"mtcars\")\ndim(mtcars)\n```\n:::\n\n\n2.  Deux caractéristiques sont mal identifiées dans le data frame car ce sont des variables qualitatives (facteurs), rectifier en utilisant la fonction as.factor.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nstr(mtcars)\nmtcars$vs=as.factor(mtcars$vs)\nmtcars$am=as.factor(mtcars$am)\n```\n:::\n\n\n3.  En utilisant l'aide du data frame mtcars renommer les niveaux des deux facteurs précédents.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nlevels(mtcars$vs)=c(\"V\",\"droit\")\nlevels(mtcars$am)=c(\"Auto\",\"Manu\")\n```\n:::\n\n\n4.  Etablir la table de contingence de ces deux facteurs (fonction table)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\ntable(mtcars$vs,mtcars$am)\n```\n:::\n\n\n5.  Calculer la moyenne des 7 premières variables (on utilisera les fonctions mean et apply).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\napply(mtcars[,1:7],2,mean)\n```\n:::\n\n\n6.  Reprendre la question pour les voitures avec un moteur à plat. De même pour les voitures ayant un moteur en V et qui sont automatiques.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\napply(mtcars[mtcars$vs==\"V\",1:7],2,mean)\napply(mtcars[mtcars$vs==\"droit\" & mtcars$am==\"Auto\",1:7],2,mean)\n```\n:::\n\n\n7.  Calculer le nombre de voitures ayant un moteur en V qui ont au moins 3 carburateurs.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Voir la correction\"}\nsum(mtcars$vs==\"V\" & mtcars$carb>=3)\n```\n:::\n",
    "supporting": [
      "partie1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}